<link rel="import" href="../polymer/polymer.html">

<!--
`array-filter`
Provides the ability to filter/sort an array and maintain bindings

@demo demo/index.html 
-->

<dom-module id="array-filter">
	<script>
		Polymer({
			is: 'array-filter',

			properties: {
				items: {
					type: Array,
					notify: true
				},
				filtered: {
					type: Array,
					notify: true
				},
				observe: {
					type: String
				},
				filter: {
					type: Function,
					observer: '_filterChanged'
				},
				sort: {
					type: Function,
					observer: '_sortChanged'
				},
				_filteredCollection: {
					type: Object
				},
				_itemsCollection: {
					type: Object
				}
			},

			observers: [
				'_itemsChanged(items.*)'
			],

			_sortChanged: function(val) {
				var host = this.domHost;
				var sort = val;
				if(typeof val !== 'function') {
					sort = function() {
						return host[val].apply(host, arguments);
					};
				}
				this._sortFn = sort;
				if(this.items) {
					this._debounceFilter();
				}
			},

			_debounceFilter: function() {
				this.debounce('_filter', this._filter);
			},

			_filterChanged: function(val) {
				var host = this.domHost;
				var filter = val;
				if(typeof filter !== 'function') {
					filter = function() {
						return host[val].apply(host, arguments);
					};
				}
				this._filterFn = filter;
				if(this.items) {
					this._debounceFilter();
				}
			},

			_itemsChanged: function(change) {
				var path = change.path;

				if(path === 'items') {
					this._debounceFilter();
				} else if(path === 'items.length') {
				} else if(path === 'items.splices') {
					this._computeSplices(change.value.keySplices, change.value.indexSplices);
				} else {
					this._checkSort(change.path);
				}
			},

			_resetLinks: function() {
				if(this.filtered) {
					var item, idx;
					for(var i = 0; i < this.filtered.length; i++) {
						item = this.filtered[i];
						idx = this._filteredCollection.getKey(item);

						this.unlinkPaths('filtered.' + idx);
						this.linkPaths(
							'filtered.' + idx,
							'items.' + this._itemsCollection.getKey(item)
						);
					}
				}
			},

			_filter: function() {
				this.filtered = this._computeFiltered(this.items);
				this._itemsCollection = Polymer.Collection.get(this.items);
				this._filteredCollection = Polymer.Collection.get(this.filtered);
				this._resetLinks();
			},

			update: function() {
				this._debounceFilter();
			},

			_computeFiltered: function(base) {
				if(!base) {
					return;
				}

				var result = base.slice(0);

				if(this._filterFn) {
					result = result.filter(this._filterFn);
				}

				if(this._sortFn) {
					result = result.sort(this._sortFn);
				}

				return result;
			},

			_computeSplices: function(keys, index) {
				index.forEach(function(splice) {
					var filtered = this._computeFiltered(splice.object);
					var inserts = [];
					var item;

					splice.removed.forEach(function(remove) {
						var idx = this._filteredCollection.getKey(remove);
						this.arrayDelete('filtered', remove);
						this.unlinkPaths('filtered.' + idx);
					}.bind(this));

					for(var i = 0; i < splice.addedCount; i++) {
						item = splice.object[splice.index + i];
						if(filtered.indexOf(item) !== -1) {
							inserts.push([item, filtered.indexOf(item)]);
						}
					}

					inserts.sort(function(a, b) {
						return a[1] - b[1];
					}).forEach(function(insert) {
						this.splice('filtered', insert[1], 0, insert[0]);
						this.linkPaths(
							'filtered.' + this._filteredCollection.getKey(insert[0]),
							'items.' + this._itemsCollection.getKey(insert[0])
						);
					}.bind(this));
				}.bind(this));
			},

			_applyObserver: function(path) {
				var parts = path.split('.');
				var filtered = this._computeFiltered(this.items);
				var item = this._itemsCollection.getItem(parts[1]);
				var idx = this._itemsCollection.getKey(item);
				var fIdx = this._filteredCollection.getKey(item);

				this.unlinkPaths('filtered.' + fIdx);
				this.splice('filtered', idx, 1);

				if(filtered.indexOf(item) !== -1) {
					this.splice(
						'filtered',
						filtered.indexOf(item),
						0,
						item
					);
				}
			},

			_checkSort: function(path) {
				var parts = path.split('.');
				var key = parts[1];

				if(this.observe && (this.sort || this.filter)) {
					if(parts.length <= 2) {
						this._debounceFilter();
					} else {
						var observe = this.observe.split(' ');
						var matches = observe.some(function(p) {
							return Polymer.Path.matches(tail, true, p);
						});
						if(matches) {
							this._applyObserver(path);
						}
					}
				}
			}
		});
	</script>
</dom-module>
